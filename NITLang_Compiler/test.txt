# Test for Step 2: Functions (Recursion)
func fact(n: int) <int> {
    if n == 0 then {
        return 1;
    } else {
        return n * fact(n - 1);
    }
}

# Test for Step 3: Scope
let var = 10; # Global 'x'

func scope_test() <int> {
    let var: int = 20; # Local 'var' shadows global
    return var + 1; # Should use local 'var'
}

# --- Step 6: Object Orientation ---
# Defining a class with private fields and methods [cite: 102-106, 158-164]
class Counter {
    let count: int;

    # Constructor
    func init(start: int) <null> {
        this.count = start;
    }

    # Method modifying internal state
    func add(n: int) <null> {
        this.count = this.count + n;
    }

    # Method returning value
    func get() <int> {
        return this.count;
    }
}

# --- Step 5: Types ---
# Explicit type declarations [cite: 98-100]
let global_val: int = 10;
let is_active: bool = true;

func main() <int> {
    print("==================== Step 1 Tests ===================="); # Start Step 1: Arithmetic, Variables, and Printing

    let x: int = 10;
    let y: int = 20;

    print(x);      # Expected: 10
    print(y);      # Expected: 20
    print(x + y);  # Expected: 30
    print(y - x);  # Expected: 10
    print(x * y);  # Expected: 200
    print(y / 2);  # Expected: 10

    # Overwrite variables
    x = 5;
    y = x + 2 + 3 * 4;
    print(y);      # Expected: 19

    print("==================== Step 2 Tests ===================="); # Start Step 2: Functions (Recursion)

    print(fact(5)); # Expected: 120

    print("==================== Step 3 Tests ===================="); # Start Step 3: Scope

    print(scope_test()); # Expected: 21 (local var = 20 + 1)
    print(var);          # Expected: 10 (global var unchanged)

    print("==================== Step 4 Tests ===================="); # Start Step 4: References

    # --- Step 4: Memory and References ---
    # References allow mutating values via a pointer [cite: 93-96]
    let a: int = 50;
    let ptr: ref = ref a;
    
    # Expected output: 50
    print(a);
    
    # Modify 'a' through 'ptr' using assignment operator :=
    ptr := 100;
    
    # Expected output: 100 (proving 'a' was modified)
    print(a);


    print("==================== Step 5 Tests ===================="); # Start Step 5: Types
    
    # --- Step 5: Types ---
    # Using the booleans declared above [cite: 99]
    if is_active then {
        print(1); # Expected
    } else {
        print(0);
    }


    print("==================== Step 6 Tests ===================="); # Start Step 6: Objects

    # --- Step 6: Object Orientation ---
    # Object instantiation and method calls [cite: 110, 165-168]
    let c = new Counter(10);
    
    c.add(5);
    c.add(5);
    
    # Expected output: 20
    print(c.get());


    print("==================== Step 7 Tests ===================="); # Start Step 7: Functional

    # --- Step 7: Functional Features ---
    # Higher-order functions (map) and Lambda expressions [cite: 112-114, 170]
    let nums: vector = [1, 2, 3, 4];
    
    # Apply lambda: x -> x * 10
    let scaled = map(lambda x -> x * 10, nums);
    
    # Verify results
    # Expected output: 4 (length)
    print(length(scaled));
    
    # Expected output: 10
    print(scaled[0]);
    # Expected output: 20
    print(scaled[1]);
    # Expected output: 40
    print(scaled[3]);

    # Expected output: [1, 2, 3, 4]
    print(nums);
    # Expected output: [10, 20, 30, 40]
    print(scaled);

    print("====================  End Tests  ===================="); # End Tests
    return 0;
}
